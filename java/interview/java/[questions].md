# Java
## Foundations
- ¿Qué es la reflexión en Java y cómo la utilizas en el desarrollo de aplicaciones?
- ¿Cuál es la diferencia entre @Component, @Service y @Repository en Spring Boot?
- ¿Cómo implementarías la autenticación basada en token JWT en una aplicación Spring Boot?
- ¿Cuál es la diferencia entre una conexión JDBC y una conexión JNDI?
- ¿Qué es el patrón DAO (Data Access Object) y cuál es su propósito en el desarrollo de aplicaciones Java?
- ¿Qué es la anotación @Transactional en Spring y cómo la utilizarías en un método de servicio?
- ¿Qué es HATEOAS (Hypermedia as the Engine of Application State) y cómo se aplica en el desarrollo de APIs RESTful?
- ¿Cómo implementarías la protección contra ataques de inyección de SQL en una aplicación Java Backend?
- ¿Cuál es la diferencia entre un Stream secuencial y un Stream paralelo?
- ¿Qué son los métodos de referencia (method references) en Java 8 y cómo se utilizan en la programación funcional?
- ¿Qué es la anotación @FunctionalInterface en Java y cuál es su propósito?

## Architectural
- ¿Cómo implementarías la tolerancia a fallos en una aplicación Spring Boot?

## Reactive Programming
- ¿Cuáles son las ventajas y desventajas de la arquitectura de microservicios en comparación con la arquitectura monolítica?
- Explica el concepto de programación reactiva en el contexto de Spring WebFlux.
- ¿Cómo manejarías de manera eficiente la concurrencia y la gestión de recursos en una aplicación Spring WebFlux?

# Docker
- ¿Cómo se puede configurar un contenedor Docker para exponer un puerto específico?
- ¿Cuál es la diferencia entre una imagen y un contenedor en Docker?
- ¿Qué es Docker Compose y cuál es su función en el despliegue de aplicaciones?

# SQL
- ¿Cómo optimizas consultas SQL para mejorar el rendimiento de una aplicación?
- ¿Cuándo elegirías una solución NoSQL sobre una base de datos relacional en una aplicación Java Backend?


Preguntas técnicas generales



¿Qué son las excepciones en Java? ¿Cómo las manejas?
Explica la diferencia entre checked y unchecked exceptions.
¿Qué es el manejo de errores con try-catch-finally en Java?

¿Cómo funciona el manejo de concurrencia en Java?
¿Qué son los hilos (threads) en Java y cómo se crean?
¿Qué es un "deadlock" y cómo lo evitas en Java?
Explica el uso de la palabra clave synchronized.
¿Qué son las colecciones en Java? Nombra algunas clases importantes del framework de colecciones.
Explica la diferencia entre ArrayList y LinkedList.
¿Cómo funciona un HashMap en Java?
¿Qué es el polimorfismo en Java?
¿Qué es la herencia y cómo se implementa en Java?
¿Qué son las interfaces y las clases abstractas en Java?
¿Cuál es la diferencia entre una clase abstracta y una interfaz?
¿Qué es la sobrecarga (overloading) y la sobrescritura (overriding) de métodos en Java?
¿Qué es una Enum en Java y cómo se usa?
¿Qué es la programación genérica en Java?
Explica la diferencia entre Comparator y Comparable.
¿Qué es el concepto de "programación orientada a objetos" (OOP) y cuáles son sus principios?
¿Qué es la serialización en Java?
¿Cómo funciona la palabra clave final en Java?
¿Qué es la reflexión (reflection) en Java y cuándo la usarías?
¿Qué son los lambdas en Java? ¿Cómo se usan?
¿Qué es un Stream en Java? Explica su uso.
Explica el patrón de diseño Singleton en Java.
¿Cómo implementas el patrón de diseño Factory en Java?
¿Qué es el patrón de diseño Observer?
¿Qué es el patrón de diseño Strategy?
¿Qué son las anotaciones en Java? ¿Puedes crear tus propias anotaciones?
Preguntas sobre frameworks y herramientas
¿Qué es Spring Framework y cuáles son sus principales módulos?
¿Cómo configuras una aplicación Spring Boot desde cero?
Explica la inyección de dependencias en Spring.
¿Qué son los componentes de Spring (@Component, @Service, @Repository)?
¿Qué es una Bean en Spring y cómo la defines?
Explica el concepto de aspecto (aspect) y programación orientada a aspectos (AOP) en Spring.
¿Qué es Spring Data JPA y cómo lo usas?
¿Cómo configuras una transacción en Spring?
¿Qué es Spring Security y cómo lo implementas?
¿Cómo manejas la autenticación y autorización en Spring Security?
Explica cómo funcionan las RestControllers en Spring.

¿Qué es un Interceptor en Spring?
¿Cómo configuras un API Gateway en un proyecto con microservicios utilizando Spring Cloud?
¿Qué es Eureka y cómo se usa en un proyecto con microservicios?
¿Qué es Feign Client y cómo lo usas en un proyecto de microservicios?
¿Cómo realizas pruebas unitarias y de integración en un proyecto Spring Boot?
¿Qué es Hibernate y cómo se diferencia de JPA?
¿Qué es la N+1 query problem y cómo lo resuelves con Hibernate?
¿Cómo configuras un DataSource en Spring?
Explica el uso de @Transactional en Spring.
¿Qué es un microservicio? ¿Cómo se implementan en Java?
¿Cómo manejas la comunicación entre microservicios en Java?
¿Qué es Docker y cómo se usa en un entorno de desarrollo Java?
¿Qué es Kubernetes y cómo despliegas una aplicación Java en él?
¿Cómo manejas la configuración externa en Spring Boot utilizando Spring Cloud Config?
¿Cómo implementas un circuito breaker en un microservicio utilizando Hystrix o Resilience4j?
¿Qué es el patrón de diseño Saga y cómo lo implementas en una arquitectura de microservicios?
¿Qué es una base de datos relacional vs una base de datos NoSQL? ¿Cuándo usarías cada una?
¿Cómo manejas la seguridad de una API REST en Java?
¿Cómo implementas OAuth2 en una aplicación Java?
¿Qué es Maven y cómo lo usas en un proyecto Java?
¿Qué es Gradle y cómo se diferencia de Maven?
¿Qué es Jenkins y cómo lo integras en un flujo de CI/CD para un proyecto Java?
¿Cómo monitorizas un servicio en producción con herramientas como Prometheus o Grafana?
¿Qué es ELK Stack y cómo lo usas para monitorizar logs de aplicaciones Java?


# Arquitectura

## ¿Cuáles son las ventajas y desventajas de la arquitectura de microservicios en comparación con la arquitectura monolítica?

### Ventajas de la arquitectura de microservicios:

- Escalabilidad: Los microservicios permiten escalar componentes individuales de la aplicación de forma independiente, lo que facilita la gestión de la carga y la optimización de recursos.
- Despliegue continuo: Los microservicios permiten implementar y actualizar componentes de la aplicación de forma independiente, lo que facilita la entrega continua y la corrección rápida de errores.
- Desacoplamiento: Los microservicios están diseñados para ser independientes y desacoplados, lo que facilita la evolución y la modificación de componentes sin afectar al resto de la aplicación.

### Desventajas de la arquitectura de microservicios:

- Complejidad: La arquitectura de microservicios introduce una mayor complejidad en el diseño, desarrollo, implementación y mantenimiento de la aplicación, ya que implica la gestión de múltiples servicios distribuidos.
- Overhead de comunicación: Los microservicios requieren comunicación a través de la red, lo que puede introducir latencia y sobrecarga en comparación con una arquitectura monolítica.
- Consistencia y coherencia: Mantener la consistencia y la coherencia de los datos entre los microservicios puede ser un desafío, ya que cada servicio tiene su propia base de datos y lógica de negocio.

### Conclusión
#### Arquitectura Monolítica
Es adecuada para aplicaciones más pequeñas o proyectos con un equipo reducido y menos requisitos de escalabilidad. Es más simple de desarrollar, desplegar y gestionar en las primeras etapas, pero puede volverse difícil de manejar a medida que la aplicación crece.

#### Arquitectura de Microservicios:
Es ideal para aplicaciones grandes y complejas que requieren escalabilidad, flexibilidad, y resiliencia. Sin embargo, la complejidad operacional y técnica es significativamente mayor, y puede no ser necesaria ni eficiente para todas las aplicaciones.


## Arrays

Los arrays son estructuras de datos que almacenan una colección de elementos del mismo tipo en una secuencia contigua de memoria. Cada elemento en un array se identifica por un índice, que representa su posición en la secuencia. Los arrays son una forma eficiente de almacenar y acceder a datos en memoria, ya que permiten un acceso aleatorio a los elementos en tiempo constante.

## Memoria 

Los arrays en Java se almacenan en memoria de forma contigua, lo que significa que los elementos se almacenan uno tras otro en direcciones de memoria adyacentes. Esto permite un acceso rápido a los elementos mediante el uso de índices, ya que el compilador puede calcular la dirección de memoria de un elemento en función de su índice y la dirección base del array. Se utiliza la memoria heap.

## Tipos de arrays

En Java, existen varios tipos de arrays, incluyendo:

- **Arrays unidimensionales**: Almacenan una colección de elementos en una sola dimensión.
- **Arrays multidimensionales**: Almacenan una colección de elementos en múltiples dimensiones, como matrices bidimensionales o tridimensionales.
- **Arrays de objetos**: Almacenan referencias a objetos en lugar de los objetos mismos.
- **Arrays de primitivos**: Almacenan valores primitivos en lugar de referencias a objetos.

## Copia de arrays

Para copiar un array en Java, puedes utilizar el método `System.arraycopy()` o el método `Arrays.copyOf()`. Ambos métodos copian los elementos de un array a otro array nuevo. Aquí tienes un ejemplo de cómo copiar un array utilizando `System.arraycopy()`:

## Jagged Arrays

Un array irregular o "jagged array" es un array multidimensional en el que cada fila puede tener un número diferente de elementos. En Java, los jagged arrays se pueden crear declarando un array de arrays, donde cada array interno puede tener un tamaño diferente.

## Puede un array ser volatil?

En Java, la palabra clave `volatile` se utiliza para indicar que una variable puede ser modificada por múltiples hilos de ejecución de forma segura. Sin embargo, `volatile` no se puede aplicar directamente a un array en Java. Si necesitas que un array sea volátil, puedes declarar el array como una variable volátil y asegurarte de que las operaciones de lectura y escritura del array se realicen de forma segura en hilos concurrentes.


## ventajas y desventajas de los arrays

### Ventajas de los arrays:

- **Acceso aleatorio**: Los arrays permiten un acceso aleatorio a los elementos en tiempo constante, lo que significa que puedes acceder a cualquier elemento en el array directamente mediante su índice.
- **Eficiencia de memoria**: Los arrays almacenan elementos de forma contigua en memoria, lo que reduce la fragmentación y mejora la eficiencia de acceso a los elementos.
- **Facilidad de uso**: Los arrays son fáciles de declarar y utilizar en Java, lo que los convierte en una estructura de datos conveniente para almacenar colecciones de elementos.

### Desventajas de los arrays:

- **Tamaño fijo**: Los arrays tienen un tamaño fijo que se determina en tiempo de creación, lo que puede ser limitante si necesitas almacenar una cantidad variable de elementos.
- **Inserción y eliminación costosas**: Insertar o eliminar elementos en un array puede ser costoso, ya que puede requerir reorganizar los elementos existentes para mantener la contigüidad.
- **Falta de métodos de utilidad**: Los arrays en Java no proporcionan métodos de utilidad para realizar operaciones comunes, como ordenar, buscar o filtrar elementos.



## IO Streams

Los streams de entrada/salida (I/O streams) en Java son una forma de leer y escribir datos desde y hacia diferentes fuentes y destinos, como archivos, redes, consolas, etc. Los streams de entrada se utilizan para leer datos, mientras que los streams de salida se utilizan para escribir datos.

## Streams

Los streams en Java 8 son una forma de procesar colecciones de datos de manera funcional y declarativa. Los streams permiten realizar operaciones como filtrado, mapeo, reducción y ordenación en colecciones de datos de forma eficiente y concisa.

## File I/O

La entrada/salida de archivos (File I/O) en Java se refiere a la lectura y escritura de datos desde y hacia archivos en el sistema de archivos. Java proporciona clases como File, FileInputStream, FileOutputStream, FileReader, FileWriter, etc., para trabajar con archivos en Java.

## BufferedI/O

Las clases BufferedInputStream y BufferedOutputStream en Java se utilizan para mejorar el rendimiento de la entrada/salida de datos al almacenar en búfer los datos leídos o escritos en memoria antes de transferirlos al sistema de archivos. Esto reduce la cantidad de operaciones de lectura/escritura en disco y mejora el rendimiento de la entrada/salida de archivos.

## sleep vs wait

- sleep:
pertenece a la clase Thread y se utiliza para pausar la ejecución del hilo actual durante un tiempo determinado en milisegundos. Durante este tiempo, el hilo permanece en estado de bloqueo temporal (timed waiting) y no ejecuta ningún código. Su propósito principal es suspender la ejecución de un hilo sin liberar los recursos ni la posesión de cualquier monitor que el hilo pueda estar sosteniendo.

- wait
pertenece a la clase Object y se utiliza en el contexto de la sincronización de hilos. Se invoca sobre un objeto que un hilo tiene bloqueado (mediante un synchronized). El hilo que llama a wait libera el bloqueo del objeto y entra en el estado de espera (waiting) hasta que otro hilo lo notifique mediante notify() o notifyAll(). Su propósito es permitir la sincronización de hilos, permitiendo que un hilo espere a que otro hilo complete alguna tarea antes de continuar.

## Synchronized

La palabra clave synchronized en Java se utiliza para crear secciones críticas de código que deben ser ejecutadas por un solo hilo a la vez. Cuando un hilo adquiere el bloqueo de un objeto mediante synchronized, ningún otro hilo puede ejecutar el código sincronizado hasta que el primer hilo libere el bloqueo.

## Volatile keyword

La palabra clave volatile en Java se utiliza para indicar que una variable puede ser modificada por múltiples hilos y que los cambios en la variable deben ser visibles para todos los hilos. La palabra clave volatile evita que los hilos almacenen en caché los valores de la variable y garantiza que los cambios en la variable sean visibles para todos los hilos.

## string vs stringbuilder vs stringbuffer

- String: Inmutable, no se puede modificar una vez creada. Cada operación de modificación crea una nueva cadena en memoria.
- StringBuilder: Mutable, se puede modificar sin crear una nueva instancia. Más eficiente para operaciones de concatenación y modificación de cadenas.
- StringBuffer: Similar a StringBuilder, pero sincronizado y seguro para hilos. Menos eficiente que StringBuilder en entornos no concurrentes.

## ¿Qué es un framework?

Conjunto de herramientas, bibliotecas y reglas que proporcionan una estructura predefinida para desarrollar aplicaciones o soluciones en un lenguaje de programación específico.

## ¿Qué es spring?

Spring es un framework que se enfoca en proporcionar una infraestructura sólida para manejar las preocupaciones comunes en las aplicaciones empresariales, como la:

- Gestión de transacciones
- La inyección de dependencias
- La integración con bases de datos
- Seguridad

## ¿Qué es Springboot?

Framework que simplifica la configuración y el desarrollo de aplicaciones al proporcionar una serie de configuraciones automáticas y herramientas que permiten a los desarrolladores centrarse más en la lógica de la aplicación en lugar de en la configuración manual del proyecto. Se ocupa de:

- Configuración automática
- Embalado sencillo
- Dependencias administradas (starters)
- Microservicios

## ¿Qué es la reflexión y como se usa en el desarrollo de aplicaciones?

Es una herramienta que permite inspeccionar o modifcar el comportamiento de un programa en tiempo de ejecución. Se usa para examinar o modificar las clases, interfaces, métodos y campos de un objeto en tiempo de ejecución, incluso si no conoces los nombres de estas estructuras en tiempo de compilación.

Se utiliza el objeto class.forName() para obtener la clase de un objeto y luego se puede obtener los métodos, campos, interfaces, etc. de la clase.

No es recomendable usar la reflexión en aplicaciones de producción, ya que puede ser inseguro y lento.

## ¿Cuál es la diferencia entre @Component, @Service, @Repository y @Configuration en Spring Boot?

### @Component

Se usa cuando no hay un propósito específico, es decir, cuando la clase no es un servicio o un repositorio, pero aún necesitas que Spring la gestione como un bean.

### @Service

Service es una especialización de Component que se utiliza para indicar que la clase es un servicio. Un servicio en la arquitectura de capas es donde resides la lógica de negocio.

### @Repository

Repository es otra especialización de Component que se utiliza para indicar que la clase es un repositorio. Un repositorio es responsable de la interacción con la base de datos, típicamente a través de consultas y operaciones CRUD. También traduce las excepciones de la base de datos a excepciones de Spring.

### @Configuration

Configuration se utiliza para indicar que la clase es una clase de configuración de Spring. Las clases de configuración de Spring se utilizan para definir beans y configurar la aplicación de Spring.

## ¿Que es @Autowired?

@Autowired es una anotación de Spring que se utiliza para inyectar dependencias automáticamente en los beans de Spring. Spring escanea el contexto de la aplicación en busca de beans que coincidan con el tipo de la propiedad o el método anotado con @Autowired y los inyecta automáticamente.

## ¿Cómo implementarías la autenticación basada en token JWT en una aplicación Spring Boot?

1 - Agregar las dependencias de Maven
2 - Crear una clase de configuración para la seguridad
3 - Crear un filtro de autenticación
4 - Crear un proveedor de autenticación, que se encargará de autenticar al usuario y generar el token JWT
5 - Proteger las rutas creando un filtro de autorización para validar el token JWT

## ¿Cómo implementarías la tolerancia a fallos en una aplicación Spring Boot?

Implementar la tolerancia a fallos en una aplicación Spring Boot implica diseñar y configurar la aplicación para que sea capaz de manejar fallos de manera eficaz y continuar funcionando o recuperarse rápidamente.

Algunas estrategias comunes para implementar la tolerancia a fallos en una aplicación Spring Boot incluyen:

- Circuit Breaker: Un Circuit Breaker (cortocircuito) es un patrón de diseño que permite que una aplicación detecte fallos en servicios externos y actúe en consecuencia para evitar sobrecargar esos servicios o realizar llamadas innecesarias. Se utilizan bibliotecas como Resilience4j o Spring Cloud Circuit Breaker para implementar Circuit Breakers en aplicaciones Spring Boot.

- Retries: Implementar reintentos automáticos en caso de fallos transitorios en llamadas a servicios externos. Se pueden utilizar bibliotecas como Spring Retry o Resilience4j para configurar reintentos automáticos en métodos específicos.

- Timeouts: Configurar tiempos de espera adecuados para las llamadas a servicios externos para evitar bloqueos o cuellos de botella en la aplicación. Se pueden configurar tiempos de espera globales o específicos para cada llamada utilizando propiedades de configuración en Spring Boot.

- Fallbacks: Proporcionar valores predeterminados o alternativos en caso de fallos en llamadas a servicios externos.

- Backoff: Implementar estrategias de backoff para reintentar llamadas a servicios externos con intervalos de tiempo crecientes en caso de fallos.

- Bulkhead: Separar y limitar el acceso a recursos críticos para evitar que un fallo en un componente afecte a otros componentes de la aplicación.

- Cache: Utilizar cachés para almacenar resultados de operaciones costosas y evitar llamadas innecesarias a servicios externos.

- Descentralización y Redundancia
  A nivel de arquitectura, puedes diseñar tu aplicación para que tenga redundancia en los servicios, utilizando patrones como microservicios o arquitecturas distribuidas que permitan distribuir la carga y evitar puntos únicos de fallo.

## ¿Cuál es la diferencia entre una conexión JDBC y una conexión JNDI?

### JDBC:

- Es una conexión directa a la base de datos desde el código de la aplicación.
- Los detalles de la conexión (URL, usuario, contraseña) están en el código de la aplicación.
- Es más adecuado para aplicaciones simples o de pequeña escala.

### JNDI:

- Es una conexión a la base de datos gestionada a través de un recurso JNDI en el servidor de aplicaciones.
- La configuración de la base de datos está separada del código y es gestionada por el servidor.
- Es más adecuado para aplicaciones grandes y complejas que requieren gestión centralizada y reutilización de configuraciones.

## ¿Qué es el patrón DAO (Data Access Object) y cuál es su propósito en el desarrollo de aplicaciones Java?

El patrón DAO (Data Access Object) es un patrón de diseño estructural que proporciona una abstracción sobre las operaciones de acceso a datos en una aplicación. En esencia, el patrón DAO separa la lógica de negocio de la lógica de acceso a datos, permitiendo que la aplicación interactúe con la base de datos de una manera consistente y desacoplada.

El propósito principal de este patrón es encapsular el código que accede a la base de datos y proporcionar una interfaz clara para realizar operaciones de lectura, escritura, actualización y eliminación (CRUD) en una fuente de datos (que podría ser una base de datos, un archivo, etc.).

## ¿Qué es la anotación @Transactional en Spring y cómo la utilizarías en un método de servicio?

La anotación @Transactional se utiliza para indicar que un método o clase debe ser ejecutado dentro de una transacción. Al utilizar esta anotación, Spring se encarga automáticamente de:

Iniciar una transacción al comienzo de la ejecución del método.
Comprometer (commit) la transacción si el método se ejecuta con éxito.
Revertir (rollback) la transacción si se lanza una excepción durante la ejecución del método

## ¿Qué es HATEOAS (Hypermedia as the Engine of Application State) y cómo se aplica en el desarrollo de APIs RESTful?

HATEOAS se refiere a la capacidad de una API RESTful para guiar al cliente a través de las interacciones posibles con el servicio utilizando hipervínculos (enlaces) dentro de las representaciones de recursos.

En una API RESTful que implementa HATEOAS, cada respuesta de la API incluye no solo los datos solicitados, sino también enlaces a otras acciones posibles relacionadas con ese recurso. Esto permite que el cliente navegue por la API sin necesidad de conocer de antemano la estructura o los endpoints disponibles.

## ¿Cuál es la diferencia entre un Stream secuencial y un Stream paralelo?

### Stream secuencial:

- Un Stream secuencial procesa los elementos de manera secuencial, uno a la vez, en un solo hilo de ejecución.
- Es útil para operaciones que no se benefician de la paralelización o que pueden ser sensibles al orden de los elementos.
- Se puede crear un Stream secuencial a partir de una colección o de un Stream paralelo utilizando el método sequential().

### Stream paralelo:

- Un Stream paralelo procesa los elementos de manera concurrente, utilizando múltiples hilos de ejecución para acelerar el procesamiento.
- Es útil para operaciones que se pueden paralelizar, como operaciones de filtrado, mapeo y reducción.
- Se puede crear un Stream paralelo a partir de una colección o de un Stream secuencial utilizando el método parallel().
- Se debe tener cuidado al utilizar Streams paralelos, ya que pueden introducir complejidad y posibles problemas de concurrencia en la aplicación.

### ¿Cuándo elegirías una solución NoSQL sobre una base de datos relacional en una aplicación Java Backend?

Algunas situaciones en las que podría ser más adecuado utilizar una base de datos NoSQL en lugar de una base de datos relacional en una aplicación Java Backend incluyen:

- Escalabilidad horizontal: Las bases de datos NoSQL suelen ser más adecuadas para escalar horizontalmente y manejar grandes volúmenes de datos distribuidos en clústeres de servidores.
- Flexibilidad en el esquema de datos: Las bases de datos NoSQL permiten un esquema de datos flexible y dinámico, lo que facilita la adaptación a cambios en los requisitos de la aplicación.
- Velocidad y rendimiento: Las bases de datos NoSQL suelen ser más rápidas y eficientes para ciertos tipos de consultas y operaciones, como consultas de lectura masiva o escrituras concurrentes.
- Modelado de datos complejos: Las bases de datos NoSQL son más adecuadas para modelar datos complejos y no estructurados, como documentos JSON o grafos.
- Escenarios de Big Data: Las bases de datos NoSQL son más adecuadas para escenarios de Big Data, como análisis de datos en tiempo real, procesamiento de eventos o almacenamiento de datos no estructurados.

## ¿Qué son los métodos de referencia (method references) en Java 8 y cómo se utilizan en la programación funcional?

Los métodos de referencia son una característica de Java 8 que permite referenciar métodos existentes o constructores de clases en lugar de definir una expresión lambda. Los métodos de referencia se utilizan en la programación funcional para simplificar la escritura de expresiones lambda y mejorar la legibilidad del código.

## ¿Qué es la anotación @FunctionalInterface en Java y cuál es su propósito?

La anotación @FunctionalInterface se utiliza para indicar que una interfaz de Java es una interfaz funcional. Una interfaz funcional es una interfaz que tiene un único método abstracto y puede ser utilizada como una expresión lambda en programación funcional.

## ¿Qué es Spring WebFlux y cuál es su propósito en el desarrollo de aplicaciones reactivas?

Spring WebFlux es un módulo de Spring Framework que proporciona soporte para el desarrollo de aplicaciones reactivas en Java. El propósito de Spring WebFlux es permitir a los desarrolladores crear aplicaciones reactivas que sean escalables, eficientes y resistentes a fallos.

La programación reactiva se basa en el principio de reactividad, que se centra en la capacidad de responder a eventos y cambios de manera eficiente y en tiempo real. Spring WebFlux utiliza el modelo de programación reactiva basado en el patrón de diseño Reactor para manejar operaciones asíncronas y no bloqueantes.

#### Componentes Principales en Programación Reactiva

- Publisher (Publicador): Es una fuente de datos que emite elementos a lo largo del tiempo.
- Subscriber (Suscriptor): Es el que recibe los elementos emitidos por el Publisher.
- Subscription (Suscripción): Es el contrato entre el Publisher y el Subscriber, que controla la emisión de elementos.
- Processor (Procesador): Actúa tanto como Publisher y Subscriber, permitiendo transformar los datos a medida que pasan por el flujo.

## Programación reactiva

